## 最长上升子序列

### 动态规划解法：用`value`数组来存储每个数字的前面有多少个小于它的数，初始设置第一个数为1，采用双重循环，第一层从第二个数往后遍历，第二层遍历它前面的数，如果前面有小于它的数，获取该数的`value`值，让临时变量k等于改`value`值加一，否则让`k=1`。如果k值大于该数的`value`值，则让`value`值为k。最后取最大的`value`值为结果。

### 贪心二分查找解法：用`value`数组来存储一个上升序列，初始第一个数是`nums`的第一个数，其余为0，从头到尾遍历`nums`数组，如果`nums[i]>value[len]`，则把`nums[i]`插入到`value[len]`后面，否则进行二分查找将其插入`value`数组，最后输出`value`数组的长度`len`即可。

## 多数元素

### 使用map计数，遍历所有数字然后计数，当有一个数个数超过总数一半时，输出该数即可

### 排序后输出中位数

### 摩尔投票法，采用不同数相抵消的思想，从头到尾遍历，先让第一个数作为候选，每当出现相同数字时，给它的个数加一，不同数字个数减一，当个数减到小于0时，更换候选。

## 求众数

### 仍然是摩尔投票法的思路，因为此题最多两个解，则设置两个候选，初始候选数字是0，个数也是0，从头到尾遍历，当遍历到的数字等于其中一个候选时让计数加一并且进入下一次循环，当计数为0了，就换候选。如果没有满足以上任何一个情况，就让计数都减一。循环结束后要检查，再遍历一遍数组计算候选的个数，如果满足大于n/3，则成立。